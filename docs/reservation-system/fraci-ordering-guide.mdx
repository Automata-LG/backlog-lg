---
title: 'Fraci를 활용한 정렬 시스템'
description: 'Fractional Indexing을 이용한 효율적인 순서 관리'
icon: 'sort'
---

## 1. Fractional Indexing 개념

### 1.1 Fractional Indexing이란?

Fractional Indexing은 리스트 아이템의 순서를 관리하는 기법으로, 아이템 사이에 무한히 새로운 아이템을 삽입할 수 있게 해주는 방식입니다.

<Note>
  **핵심 원리**
  - 각 아이템에 소수점 기반의 인덱스 할당
  - 두 아이템 사이에 새 아이템 삽입 시 중간값 계산
  - 전체 리스트 재정렬 없이 순서 변경 가능
</Note>

### 1.2 기존 방식의 문제점

#### displayOrder 방식의 한계
```typescript
// 문제 상황: 1과 2 사이에 아이템 삽입
items = [
  { id: 'A', displayOrder: 1 },
  { id: 'B', displayOrder: 2 },
  { id: 'C', displayOrder: 3 }
];

// 해결책 1: 모든 아이템 재정렬 (비효율적)
// 해결책 2: 소수점 사용 (1.5) - 제한적
```

### 1.3 Fraci 라이브러리 장점

- ✅ **무한 정밀도**: 아이템 사이 무한 삽입 가능
- ✅ **충돌 방지**: 자동 인덱스 재생성
- ✅ **성능 최적화**: 단일 UPDATE 쿼리로 순서 변경
- ✅ **타입 안전성**: TypeScript 완벽 지원
- ✅ **ORM 통합**: Prisma 네이티브 지원

## 2. 레스토랑 예약 시스템 정렬 요구사항

### 2.1 정렬이 필요한 영역

<CardGroup cols={2}>
  <Card title="메뉴 아이템" icon="utensils">
    - 런치/디너 코스 순서
    - 카테고리 내 메뉴 정렬
    - 추천 메뉴 우선 배치
  </Card>
  
  <Card title="Section/Unit" icon="table-cells">
    - 레스토랑 구역 표시 순서
    - 테이블 배치 순서
    - 룸/홀 구분 정렬
  </Card>
</CardGroup>

### 2.2 관리자 요구사항

- 드래그앤드롭으로 직관적인 순서 변경
- 실시간 순서 업데이트
- 여러 아이템 일괄 재정렬

## 3. Fraci 구현 가이드

### 3.1 Prisma 스키마 설정

```prisma
// ReservationPriceItem - 메뉴 아이템
model ReservationPriceItem {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  contentId   String   @db.Uuid
  
  name        String   
  description String?
  basePrice   Int
  images      String[]
  category    String?
  
  // Fractional Index 필드
  index       String   // fraci가 관리하는 정렬 인덱스
  
  content     ReservationContent @relation(fields: [contentId], references: [id])
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@unique([contentId, index])  // content별로 유니크한 index
}

// ReservationSection - 구역 정렬 (선택적)
model ReservationSection {
  id           String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  spaceId      String @db.Uuid
  name         String
  
  // Fractional Index 필드
  index        String
  
  space        ReservationSpace @relation(fields: [spaceId], references: [id])
  units        ReservationUnit[]
  
  @@unique([spaceId, index])
}
```

### 3.2 Prisma 확장 설정

```typescript
// apps/emapp/src/router/prisma.ts

import { prismaFraci, definePrismaFraci } from 'fraci/prisma';
import { BASE62 } from 'fraci';

const prisma = prismaClient
  .$extends(
    prismaFraci(
      prismaClient,
      definePrismaFraci(prismaClient, {
        fields: {
          // 메뉴 아이템 정렬
          'reservationPriceItem.index': {
            group: ['contentId'],  // content별로 독립적인 정렬
            digitBase: BASE62,     // 62진법 사용 (0-9, a-z, A-Z)
            lengthBase: BASE62,
          },
          
          // 섹션 정렬 (선택적)
          'reservationSection.index': {
            group: ['spaceId'],    // space별로 독립적인 정렬
            digitBase: BASE62,
            lengthBase: BASE62,
          },
        },
      }),
    ),
  );

// Fraci 인스턴스 export
export const reservationPriceItemFi = prisma.reservationPriceItem.fraci('index');
export const reservationSectionFi = prisma.reservationSection.fraci('index');
```

### 3.3 에러 처리 및 헬퍼 함수

#### Fraci 내장 에러 처리
```typescript
import { getFraciErrorCode } from 'fraci';
import { Prisma } from '@freed/prisma';

// fraci 인스턴스에는 isIndexConflictError가 내장되어 있음
const reservationPriceItemFi = prisma.reservationPriceItem.fraci('index');

// 사용 예시
try {
  // ...
} catch (error) {
  if (reservationPriceItemFi.isIndexConflictError(error)) {
    // 유니크 제약 충돌 처리
  }
}
```

#### withKeyBetween 헬퍼 함수
```typescript
async function withKeyBetween<T>(
  fraci: ReturnType<typeof prisma.reservationPriceItem.fraci>,
  generator: Generator<string, never, unknown>,
  callback: (fi: string) => Promise<T>,
): Promise<T> {
  try {
    for (const fi of generator) {
      try {
        return await callback(fi);
      } catch (error) {
        if (fraci.isIndexConflictError(error)) {
          // 충돌 발생 - 재생성 후 재시도
          continue;
        }
        throw error;
      }
    }
    
    // generateKeyBetween이 MAX_RETRIES_EXCEEDED 에러를 던지기 전까지 도달하지 않음
    throw new Error('Unreachable');
  } catch (error) {
    const code = getFraciErrorCode(error);
    if (code === 'MAX_LENGTH_EXCEEDED') {
      throw new TRPCError({ 
        code: 'INTERNAL_SERVER_ERROR', 
        message: '더 이상 아이템을 추가할 수 없습니다.' 
      });
    }
    if (code === 'MAX_RETRIES_EXCEEDED') {
      throw new TRPCError({ 
        code: 'TOO_MANY_REQUESTS', 
        message: '동시 요청이 너무 많습니다. 다시 시도해주세요.' 
      });
    }
    throw error;
  }
}
```

### 3.4 기본 CRUD 작업

#### 메뉴 생성 (마지막에 추가)
```typescript
async function createMenuItem(data: {
  contentId: string;
  name: string;
  basePrice: number;
  description?: string;
  category?: string;
  images?: string[];
}) {
  // 마지막 위치의 인덱스 가져오기
  const indices = await reservationPriceItemFi.indicesForLast({ 
    contentId: data.contentId 
  });
  
  // withKeyBetween 헬퍼로 충돌 처리
  return await withKeyBetween(
    reservationPriceItemFi.generateKeyBetween(...indices),
    async (index) => {
      return await prisma.reservationPriceItem.create({
        data: {
          ...data,
          index,
        },
      });
    }
  );
}
```

#### 메뉴 목록 조회
```typescript
async function getMenuItems(contentId: string) {
  return await prisma.reservationPriceItem.findMany({
    where: { contentId },
    orderBy: { index: 'asc' },  // fractional index 순서로 정렬
  });
}
```

#### 특정 위치에 메뉴 삽입
```typescript
async function insertMenuItem(
  data: CreateMenuData,
  position: 'before' | 'after',
  targetItemId: string
) {
  // 타겟 아이템 앞/뒤 인덱스 가져오기
  const indices = position === 'before'
    ? await reservationPriceItemFi.indicesForBefore(
        { contentId: data.contentId },
        { id: targetItemId }
      )
    : await reservationPriceItemFi.indicesForAfter(
        { contentId: data.contentId },
        { id: targetItemId }
      );
  
  if (!indices) {
    throw new Error('Target item not found');
  }
  
  // withKeyBetween 헬퍼로 충돌 처리
  return await withKeyBetween(
    reservationPriceItemFi.generateKeyBetween(...indices),
    async (index) => {
      return await prisma.reservationPriceItem.create({
        data: {
          ...data,
          index,
        },
      });
    }
  );
}
```

#### 여러 메뉴 한 번에 생성
```typescript
async function createMultipleMenuItems(
  contentId: string,
  items: Array<{ name: string; basePrice: number; /* ... */ }>
) {
  // 첫 번째 위치의 인덱스 가져오기
  const indices = await reservationPriceItemFi.indicesForFirst({ 
    contentId 
  });
  
  // generateNKeysBetween은 충돌 시 재생성을 위해 Generator 반환
  try {
    for (const newIndices of reservationPriceItemFi.generateNKeysBetween(
      ...indices,
      items.length
    )) {
      try {
        // Prisma로 일괄 생성
        return await prisma.reservationPriceItem.createMany({
          data: items.map((item, index) => ({
            ...item,
            contentId,
            index: newIndices[index],
          })),
        });
      } catch (error) {
        if (reservationPriceItemFi.isIndexConflictError(error)) {
          continue; // 충돌 시 재시도
        }
        throw error;
      }
    }
    throw new Error('Unreachable');
  } catch (error) {
    const code = getFraciErrorCode(error);
    // 에러 처리...
    throw error;
  }
}
```

### 3.5 순서 변경 작업

#### 단일 아이템 이동
```typescript
async function reorderMenuItem(
  itemId: string,
  position: 'before' | 'after',
  targetItemId: string,
  contentId: string  // 그룹 필터링을 위해 필요
) {
  // 타겟 위치의 인덱스 가져오기
  const indices = position === 'before'
    ? await reservationPriceItemFi.indicesForBefore(
        { contentId },
        { id: targetItemId }
      )
    : await reservationPriceItemFi.indicesForAfter(
        { contentId },
        { id: targetItemId }
      );
  
  if (!indices) {
    throw new Error('Target position not found');
  }
  
  // withKeyBetween 헬퍼로 충돌 처리
  return await withKeyBetween(
    reservationPriceItemFi.generateKeyBetween(...indices),
    async (index) => {
      const result = await prisma.reservationPriceItem.update({
        where: { 
          id: itemId,
          contentId  // 중요: 항상 그룹 컬럼으로 필터링
        },
        data: { index }
      });
      
      if (!result) {
        throw new Error('Item not found or does not belong to this content');
      }
      
      return result;
    }
  );
}
```

#### 전체 재정렬
```typescript
async function reorderAllItems(
  contentId: string,
  orderedItemIds: string[]
) {
  // 첫 번째 위치의 인덱스 가져오기
  const indices = await reservationPriceItemFi.indicesForFirst({ 
    contentId 
  });
  
  // generateNKeysBetween은 충돌 시 재생성을 위해 Generator 반환
  try {
    for (const newIndices of reservationPriceItemFi.generateNKeysBetween(
      ...indices,
      orderedItemIds.length
    )) {
      try {
        // 트랜잭션으로 각 아이템 업데이트
        return await prisma.$transaction(async (tx) => {
          await Promise.all(
            orderedItemIds.map((itemId, index) =>
              tx.reservationPriceItem.update({
                where: { 
                  id: itemId,
                  contentId  // 중요: 항상 그룹 컬럼으로 필터링
                },
                data: { index: newIndices[index] }
              })
            )
          );
        });
      } catch (error) {
        if (isIndexConflictError(error)) {
          continue; // 충돌 시 재시도
        }
        throw error;
      }
    }
    throw new Error('Unreachable');
  } catch (error) {
    const code = getFraciErrorCode(error);
    if (code === 'MAX_LENGTH_EXCEEDED') {
      throw new TRPCError({ 
        code: 'INTERNAL_SERVER_ERROR', 
        message: '인덱스 길이 제한 초과' 
      });
    }
    if (code === 'MAX_RETRIES_EXCEEDED') {
      throw new TRPCError({ 
        code: 'TOO_MANY_REQUESTS', 
        message: '동시 요청이 너무 많습니다' 
      });
    }
    throw error;
  }
}
```

## 4. 드래그앤드롭 통합

### 4.1 React DnD 예제

```typescript
import { DragDropContext, Droppable, Draggable } from 'react-beautiful-dnd';

function MenuManager({ contentId }: { contentId: string }) {
  const [items, setItems] = useState<MenuItem[]>([]);
  
  // 드래그 완료 핸들러
  const handleDragEnd = async (result: DropResult) => {
    if (!result.destination) return;
    
    const sourceIndex = result.source.index;
    const destIndex = result.destination.index;
    
    if (sourceIndex === destIndex) return;
    
    const movedItem = items[sourceIndex];
    const targetItem = items[destIndex];
    
    // API 호출로 순서 변경
    await reorderMenuItem(
      movedItem.id,
      sourceIndex < destIndex ? 'after' : 'before',
      targetItem.id
    );
    
    // UI 업데이트
    const newItems = Array.from(items);
    const [removed] = newItems.splice(sourceIndex, 1);
    newItems.splice(destIndex, 0, removed);
    setItems(newItems);
  };
  
  return (
    <DragDropContext onDragEnd={handleDragEnd}>
      <Droppable droppableId="menu-list">
        {(provided) => (
          <div {...provided.droppableProps} ref={provided.innerRef}>
            {items.map((item, index) => (
              <Draggable key={item.id} draggableId={item.id} index={index}>
                {(provided) => (
                  <div
                    ref={provided.innerRef}
                    {...provided.draggableProps}
                    {...provided.dragHandleProps}
                  >
                    <MenuItemCard item={item} />
                  </div>
                )}
              </Draggable>
            ))}
            {provided.placeholder}
          </div>
        )}
      </Droppable>
    </DragDropContext>
  );
}
```

### 4.2 API 엔드포인트

```typescript
// tRPC router
export const menuRouter = router({
  // 메뉴 생성
  create: procedure
    .input(z.object({
      contentId: z.string(),
      name: z.string(),
      basePrice: z.number(),
      description: z.string().optional(),
      category: z.string().optional(),
      beforeId: z.string().optional(),  // 특정 위치에 삽입
    }))
    .mutation(async ({ input }) => {
      const { beforeId, ...data } = input;
      
      if (beforeId) {
        // 특정 위치에 삽입
        return await insertMenuItem(data, 'before', beforeId);
      } else {
        // 마지막에 추가
        return await createMenuItem(data);
      }
    }),
  
  // 메뉴 순서 변경
  reorder: procedure
    .input(z.object({
      itemId: z.string(),
      position: z.enum(['before', 'after']),
      targetItemId: z.string(),
    }))
    .mutation(async ({ input }) => {
      return await reorderMenuItem(
        input.itemId,
        input.position,
        input.targetItemId
      );
    }),
    
  // 전체 재정렬
  reorderAll: procedure
    .input(z.object({
      contentId: z.string(),
      orderedIds: z.array(z.string()),
    }))
    .mutation(async ({ input }) => {
      return await reorderAllItems(
        input.contentId,
        input.orderedIds
      );
    }),
});
```

## 5. 실전 예제

### 5.1 레스토랑 메뉴 관리 시나리오

```typescript
// 1. 초기 메뉴 생성 (마지막에 추가)
const lunchA = await createMenuItem({
  contentId: 'restaurant-001',
  name: '런치 A코스',
  basePrice: 35000,
  category: '런치',
});

const lunchB = await createMenuItem({
  contentId: 'restaurant-001',
  name: '런치 B코스',
  basePrice: 45000,
  category: '런치',
});

// 2. 새 메뉴를 특정 위치에 삽입
const lunchSpecial = await insertMenuItem(
  {
    contentId: 'restaurant-001',
    name: '오늘의 특선',
    basePrice: 40000,
    category: '런치',
  },
  'after',
  lunchA.id  // A코스 다음에 삽입
);

// 3. 메뉴 순서 변경 (특선을 맨 앞으로)
await reorderMenuItem(
  lunchSpecial.id,
  'before',
  lunchA.id
);

// 4. 카테고리별 조회
const menus = await prisma.reservationPriceItem.findMany({
  where: { 
    contentId: 'restaurant-001',
    category: '런치'
  },
  orderBy: { index: 'asc' }  // fraci index로 정렬
});

// 5. 여러 메뉴 한 번에 추가 (일괄 생성)
await createMultipleMenuItems('restaurant-001', [
  { name: '디너 A코스', basePrice: 65000, category: '디너' },
  { name: '디너 B코스', basePrice: 85000, category: '디너' },
  { name: '프리미엄 코스', basePrice: 120000, category: '디너' },
]);
```

### 5.2 마이그레이션 가이드

기존 displayOrder를 사용하던 시스템에서 fraci로 전환:

```typescript
async function migrateToFraci() {
  // 1. 모든 content 조회
  const contents = await prisma.reservationContent.findMany({
    include: {
      priceItems: {
        orderBy: { displayOrder: 'asc' }  // 기존 순서
      }
    }
  });
  
  // 2. content별로 fraci index 할당
  for (const content of contents) {
    if (content.priceItems.length === 0) continue;
    
    // 첫 번째 위치의 인덱스 가져오기
    const indices = await reservationPriceItemFi.indicesForFirst({ 
      contentId: content.id 
    });
    
    // 충돌 처리를 위한 Generator 사용
    try {
      for (const newIndices of reservationPriceItemFi.generateNKeysBetween(
        ...indices,
        content.priceItems.length
      )) {
        try {
          // 트랜잭션으로 일괄 업데이트
          await prisma.$transaction(async (tx) => {
            await Promise.all(
              content.priceItems.map((item, index) =>
                tx.reservationPriceItem.update({
                  where: { 
                    id: item.id,
                    contentId: content.id
                  },
                  data: { index: newIndices[index] }
                })
              )
            );
          });
          break; // 성공 시 다음 content로
        } catch (error) {
          if (reservationPriceItemFi.isIndexConflictError(error)) {
            continue; // 충돌 시 재시도
          }
          throw error;
        }
      }
    } catch (error) {
      console.error(`Migration failed for content ${content.id}:`, error);
      // 에러 로깅 후 계속 진행 또는 중단 결정
    }
  }
  
  // 3. displayOrder 컬럼 제거 (선택적)
  // ALTER TABLE "ReservationPriceItem" DROP COLUMN "displayOrder";
}
```

## 6. 주의사항 및 베스트 프랙티스

<Warning>
  **주의사항**
  - index 필드를 직접 수정하지 마세요
  - **항상 그룹 컬럼(contentId)으로 필터링** - 보안상 매우 중요
  - generateKeyBetween/generateNKeysBetween은 Generator를 반환
  - 충돌 처리를 위해 for...of 루프와 continue 패턴 사용
</Warning>

### 성능 최적화
- 정렬된 목록은 캐싱 고려
- 드래그앤드롭 시 낙관적 업데이트 적용
- 대량 작업은 트랜잭션으로 처리
- withKeyBetween 헬퍼로 반복 로직 재사용

### 에러 처리
```typescript
// Fraci 에러 코드별 처리
const code = getFraciErrorCode(error);
switch (code) {
  case 'MAX_LENGTH_EXCEEDED':
    // 인덱스가 너무 길어짐 - 재정렬 필요
    break;
  case 'MAX_RETRIES_EXCEEDED':
    // 너무 많은 충돌 - 동시 요청 제한 필요
    break;
  default:
    // 기타 에러
}
```

### 보안 고려사항
- **그룹 간 이동 방지**: 모든 쿼리에 contentId 포함
- 권한 검증 후 순서 변경 허용
- 유니크 제약 충돌 시 자동 재시도로 동시성 처리